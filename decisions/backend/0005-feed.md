# 5. Feed

Date: 2020-09-13

## Status

Discussion

## Decision

### Выборка фида с клиента

Фид выбирается с параметрами

- **from** - начиная с этой отметки выбирается вниз, если 0 (или параметр не задан), то выбираются последние записи.
- **to** - выбирается до этой отметки (необязательный параметр)
- **limit** - выбрать не больше чем записей

Как это выглядит на клиенте.

Первый запрос\
*feed?limit=50* (from == 0 by default). Выбираются 50 последних review, запоминается метка верхней записи (latest_review_id) и нижней записи (earliest_review_id).

Приложение выходит из бекграунда или нотификация об обновлении\
*feed?limit=50&to=latest_review_id*. Выбираем всё что произошло с момента последней выборки. Если возвращается к-во записей ==limit, то повторять запрос, пока не будут выбраны все (вернулось меньше чем limit).

Юзер скроллит вниз до конца списка\
*feed?limit=50&from=earliest_review_id*. Если выбирается меньше чем limit, значит достигнут конец фида.

### Формирование фида на сервере

1) Новый сервис dispatcher - слушает очередь PubSub

2) При создании review (api/reviews/review/:id/complete) в топик pubsub бросается event типа 
```
{
	"event_type": "review_created",
	"user_id": "...",
	"review_id": "..."
}
```

3) dispatcher принимает событие и выполняет след. операции

- выбрать review из базы

- если ревью публичное, то выбрать всех подписчиков на аккаунт user_id
- если ревью приватное, то выбрать всех подписчиков запросы которых были approved

- для каждого user в списке в feed добавляется запись о ревью (и отправляется нотификация, реализуется потом)

4) Feed хранится в Datastore, native mode. 

У них там есть возможность построения иерархических записей (entities group)
Root entity - User, дальше идут reviews в том порядке в котором пользователь видит их в feed. *Этот вопрос нуждается в дополнительной проработке.*

Ещё вопрос. Что конкретно хранить в NoSQL, а что подтягивать из базы при запросе фида?
Я предлагаю в первой версии хранить сам ревью + список фотографий (places + users из базы), но вообще это *очень дискуссионный вопрос*.

Думаю что нужно реализовать какую то версию, а дальше смотреть на производительность.

5) Обработка запроса на выборку feed

В качестве timestamp предлагаю использовать review_id, так как они целочисленные и последовательные. По идее created_time & review_id будут давать
одинаковые результаты, но id лучше из-за уникальности (использование времени может приводить к коллизиям).

- из Datastore выбирается список review согласно параметрам запроса
- из базы выбираются places для review в полученном списке
- из базы выбираются пользователи для review 

Фомируется ответ, отправляется на клиент.


## Consequences

What becomes easier or more difficult to do and any risks introduced by the change that will need to be mitigated.
